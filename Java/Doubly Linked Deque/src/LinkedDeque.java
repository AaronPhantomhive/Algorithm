/**   A class that implements the ADT deque by using a doubly linked chain of nodes.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class LinkedDeque<T> implements DequeInterface<T>{	private DLNode firstNode; // References node at front of deque	private DLNode lastNode;  // References node at back of deque	public int size;		public LinkedDeque()	{//		firstNode = null;//		lastNode = null;	} // end default constructor		public void clear()	{		firstNode = null;		lastNode = null;	} // end clear	public void addToBack(T newEntry)	{		DLNode newNode = new DLNode(lastNode, newEntry, null);		if(isEmpty())		{			firstNode = newNode;			lastNode = newNode;		}else {			lastNode.next = newNode;			newNode.previous = lastNode;			newNode.next = null;			lastNode= newNode;		}		size++;	} // end addToBack	public void addToFront(T newEntry)	{		DLNode newNode = new DLNode(null, newEntry, firstNode);		if(isEmpty())		{			lastNode = newNode;			firstNode = newNode;		}else {			firstNode.previous = newNode;			newNode.next = firstNode;			newNode.previous = null;			firstNode = newNode;		}		size++;	} // end addToFront   	public T getBack()	{		if(isEmpty())			throw new EmptyQueueException();		else			return lastNode.getData();	} // end getBack   	public T getFront()	{		if(isEmpty())			throw new EmptyQueueException();		else			return firstNode.getData();	} // end getFront		public T removeFront()	{		T front = null;		if (!isEmpty())		{		front = firstNode.getData();		firstNode = firstNode.next;		if (firstNode == null)			lastNode = null;		else			firstNode.previous = null;		}		size--;		return front;	} // end removeFront				public T removeBack()	{		T back = null;		if (!isEmpty())		{		back = lastNode.getData();		lastNode = lastNode.previous;		if (lastNode == null)			firstNode = null;		else			lastNode.next = null;		}		size++;		return back;	} // end removeBack	public boolean isEmpty()	{		return firstNode == null;	} // end isEmpty		/**	* 	* The string is formed using the data from the front to the back of the deque.	* If a deque has the following data: Front-> Ava, Joe, Sarah, Robert <-Back then	* the toString should return a string "[Ava, Joe, Sarah, Robert]"	* It returns "[]" for an empty deque	* @return a string representing the content of the deque from the front to the back.	*/ 		public String toString()	{		String str = "[";		DLNode current = firstNode;		while(current != null)		{			if (current.next == null)			{				str += current.getData();			} else			{				str += current.getData() + ", ";			}            current = current.getNext();		}		str += "]";		return str;	}		private class DLNode	{		private T      data;  	 // Deque entry		private DLNode next;  	 // Link to next node		private DLNode previous; // Link to previous node		private DLNode(T data)		{			this.data = data;			next = null;				previous = null;			} // end constructor				public LinkedDeque<T>.DLNode getNext() {			return next;		}		public T getData() {			return data;		}		private DLNode(DLNode previousNode, T data, DLNode nextNode)		{			this.data = data;			next = nextNode;				previous = previousNode;		} // end constructor				// You can add getters and setters for the other two references			} // end DLNode} // end LinkedDeque